# 7월 25일
> 데이터 구조(Data Structure)

# 데이터 구조(Data Structure)
- 순서가 있는 데이터 구조
  - 문자열(String)
  - 리스트(List)
  - 튜플(Tuple)
- 순서가 없는 데이터 구조
  - 셋(Set)
  - 딕셔너리(Dictionary)
- 얕은 복사와 깊은 복사

> 데이터 구조 활용
- 데이터 구조를 활용하기 위해서는 메서드(method)를 활용
  - 메서드는 클래스 내부에 정의한 함수, 사실상 함수 동일
  - 쉽게 설명하자면 객체의 기능(추후 객체 지향 프로그래밍에서 학습)

- `데이터 구조.메서드()` 형태로 활용.
  
> 데이터 구조 활용 예시
- 메서드(method)
  ```python
  List.append(10)
  String.split()
  ```
> 파이썬 공식 문서의 표기법(배커스-나우르 표기법)
- 컴퓨터 언어에서 언어의 문법을 수학적인 수식으로 나타낼 때 사용하는 언어 도구
- 프로그래밍 언어의 구문을 기술하는 데 매우 자연스러운 표기법
  - python 구문이 아니며, 배커스-나우르 표기법(문서 표준이 뿐)
  - 아래 예시에서 `str.replace(old, new[,count])`
    - `old, new`는 필수/`[,count]`는 선택적 인자를 의미함


## 순서가 있는 데이터 구조
### 문자열(String Type)
> 문자열(String Type)
- 문자들의 나열(sequence of characters)
  - 모든 문자는 str 타입(변경 불가능한 immutable)
- 문자열은 작은 따옴표(')나 큰 따옴표(")를 활용하여 표기
  - 문자열을 묶을 때 동일한 문장부호를 활용
  - PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함

> 문자열 조회/탐색 및 검증 메서드
- `s.find(x)`
  - x의 첫 번째 위치를 반환, 없으면, -1을 반환
- `s.index(x)`
  - x의 첫 번째 위치를 반환, 없으면, 오류 발생
- `s.isalpha()`
  - 알파벳 문자 여부
    - 단순 알파벳이 아닌 유니코드 상 Letter (한국어도 포함)
- `s.isupper()`
  - 대문자 여부
- `s.islower()`
  - 소문자 여부
- `s.istitle()`
  - 타이틀 형식 여부
- `.isdecimal()` <= `.isdigit()` <= `.isnumeric()`

> 문자열 변경 메서드(s는 문자열)
- `s.replace(old, new[, count])`
  - 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
  - count를 지정하면, 해당 개수만큼만 시행
- `s.strip([chars])`
  - 공백이나 특정 문자를 제거
  - 특정한 문자들을 지정하면,
    - 양쪽을 제거하거나(strip), 왼쪽을 제거하거나(lstrip), 오른쪽을 제거(rstrip)
  - 문자열을 지정하지 않으면 공백을 제거함
- `s.split(sep=None, maxsplit=-1)`
  - 공백이나 특정 문자를 기준으로 분리
  - 문자열을 특정한 단위로 나눠 리스트로 반환
    - sep이 None이거나 지정되지 않으면 연속된 공백문자를 단일한 공백문자로 간주하고, 선행/후행 공백은 빈 문자열에 포함시키지 않음.
    - maxsplit이 -1인 경우에는 제한이 없음.
- `'separator'.join([iterable])`
  - 구분자로 iterable을 합침
  - 반복가능한(iterable) 컨테이너 요소들을 separator(구분자)로 합쳐 문자열 반환
    - iterable에 문자열이 아닌 값이 있으면 TypeError 발생
- `s.capitalize()`
  - 가장 첫 번째 글자를 대문자로 변경
- `s.title()`
  - 문자열 내 띄어쓰기 기준으로 각 단어의 첫글자는 대문자로, 나머지는 소문자로 변환
- `s.upper()`
  - 모두 대문자로 변경
- `s.lower()`
  - 모두 소문자로 변경
- `s.swapcase()`
  - 대<->소문자 서로 변경

> 문자열은 immutable(불변형)인데, 문자열 변경이 되는 이유?
- 기존의 문자열을 변경하는 게 아니라, 변경된 문자열을 새롭게 만들어서 반환

### 리스트(List)
> 리스트
- 리스트는 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용

> 리스트의 생성과 접근
- 리스트는 대괄호([]) 혹은 `list()`를 통해 생성
  - 파이썬에서는 어떠한 자료형도 저장할 수 있으며, 리스트 안에 리스트도 넣을 수 있음
  - 생성된 이후 내용 변경이 가능 -> 가변 자료형
  - 이러한 유연성 때문에 파이썬에서 가장 흔히 사용
- 순서가 있는 시퀀스로 인덱스를 통해 접근 가능
  - 값에 대한 접근은 `list[i]`

> 리스트 메서드
- `L.append(X)`
  - 리스트 마지막에 항목 x를 추가
- `L.insert(i, x)`
  - 리스트 인덱스 i에 항목 x를 삽입
    - 리스트 길이보다 큰 경우 맨 뒤에 삽입
- `L.remove(x)`
  - 리스트 가장 왼쪽에 있는 항목(첫 번째) x를 제거
  - 항목이 존재하지 않을 경우, ValueError
- `L.pop()`
  - 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거
- `L.pop(i)`
  - 리스트의 인덱스 i에 있는 항목을 반환 후 제거
- `L.clear(i)`
  - 모든 항목을 삭제함
- `L.extend(m)`
  - 순회형 m의 모든 항목들의 리스트 끝에 추가 (+=과 같은 기능)
  - 리스트에 iterable의 항목을 추가함
- `L.index(x, start, end)`
  - 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환
- `L.reverse()`
  - 리스트의 순서를 반대로 뒤집음 (정렬하는 것이 아님)
- `L.sort()`
  - 원본 리스트를 정렬(매개변수 이용가능), None 반환
  - sorted 함수는 정렬된 리스트를 반환, 원본 변경 없음
- `L.count(x)`
  - 리스트에서 항목 x가 몇 개 존재하는지 갯수를 반환

### 튜플(Tuple)
> 튜플의 정의
- 튜플은 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
  - 리스트와의 차이점은 생성 후, 담고 있는 값 변경이 불가 (불변 자료형)
- 항상 소괄호 형태로 사용

> 튜플 관련 메서드
- 튜플은 변경할 수 없기 때문에 값에 영향을 미치지 않는 메서드만을 지원
- 리스트 메서드 중 항목을 변경하는 메서드들을 제외하고 대부분 동일

### 연산자(Operator)
> 멤버십 연산자(Membership Operator)
- 포함 여부 확인
  - in
  - not in
  
> 시퀀스형 연산자(Sequence Type Operator)
- 산술연산자 (+)
  - 시퀀스 간의 concatenation(연결/연쇄)
- 반복연산자 (*)
  - 시퀀스를 반복




## 비시퀀스형 데이터 구조
- 순서가 없는 데이터 구조

### 셋(Set)
> 셋
- Set이란 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
  - 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
  - 순서가 없기 때문에 인덱스를 이용한 접근 불가능
- 수학에서의 집합을 표현한 컨테이너
  - 집합 연산이 가능(여집합을 표현하는 연산자는 별도로 존재하지 않음)
  - 중복된 값이 존재하지 않음
- 담고 있는 요소를 삽입 변경, 삭제 가능 -> 가변 자료형 (mutable)

> 셋 메서드
- `s.copy()`
  - 셋의 얕은 복사본을 반환
- `s.add(x)`
  - 항목 x가 셋 s에 없다면 추가
- `s.pop()`
  - 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거
  - set이 비어 있을 경우, KeyError
- `s.remove(x)`
  - 항목 x를 셋 s에서 삭제
  - 항목이 존재하지 않을 경우, KeyError
- `s.discard(x)`
  - 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제
- `s.update(t)`
  - t에 있는 모든 항목 중 셋 s에 없는 항목을 추가
  - t는 리스트도 가능
- `s.clear()`
  - 모든 항목을 제거
- `s.isdisjoint(t)`
  - 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True 반환
- `s.issubset(t)`
  - 셋 s가 셋 t의 하위 셋인 경우, True 반환
- `s.issuperset(t)`
  - 셋 s가 셋 t의 상위 셋인 경우, True 반환

### 딕셔너리(Dictionary)
> 딕셔너리의 정의
- 키-값(key-value) 쌍으로 이뤄진 자료형(3.7부터는 ordered, 이하 버전은 unordered)
- Dictionary의 키(key)
  - key는 변경 불가능한 데이터(immutable)만 사용 가능
    - string, integer, float, boolean, tuple, range
- 각 키의 값(values)
  - 어떠한 형태든 관계없음

> 딕셔너리 메서드
- `d.clear()`
  - 모든 항목을 제거
- `d.copy()`
  - 딕셔너리 d의 얕은 복사본을 반환
- `d.keys()`
  - 딕셔너리 d의 모든 키를 담은 뷰를 반환
- `d.values()`
  - 딕셔너리 d의 모든 값을 담은 뷰를 반환
- `d.items()`
  - 딕셔너리 d의 모든 키-값의 쌍을 담은 뷰를 반환
- `d.get(k)`
  - 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 None을 반환
- `d.get(k, v)`
  - 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 v를 반환
- `d.pop(k)`
  - 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데,
  - 키 k가 딕셔너리 d에 없을 경우 KeyError를 발생
- `d.pop(k, v)`
  - 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데,
  - 키 k가 딕셔너리 d에 없을 경우 v를 반환 
- `d.update([key = value])`
  - 딕셔너리 d의 값을 매핑하여 업데이트
  - 값을 제공하는 key, value로 덮어씁니다.

## 얕은 복사와 깊은 복사
### 얕은 복사와 깊은 복사 (Shallow Copy & Deep Copy)
> 복사 방법
- 할당 (Assignment)
- 얕은 복사 (Shallow copy)
- 깊은 복사 (Deep copy)

> 할당(assignment)
- 대입 연산자 (=)
  - 대입 연산자를 통한 복사는 해당 객체에 대한 객체 참조를 복사
  - 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향

> 얕은 복사(shallow copy)
- Slice 연산자([:]) 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사 (다른 주소)

> 얕은 복사 주의사항
- 복사하는 리스트의 원소가 주소를 참조하는 경우 
  - 주소에 해당하는 값 변경시 같이 변경됨

> 깊은 복사(deep copy)
- 리스트를 복사하여 완전히 별개의 리스트 생성

