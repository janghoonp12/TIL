# Computational Thinking
> 기초 논리 & 수학

0. 서론 - 프로그래밍과 논리/수학
1. 논리와 증명
2. 수와 표현
3. 집합과 조합론
4. 기초 수식
5. 재귀
6. 동적 프로그래밍

## 서론 - 프로그래밍과 논리/수학
- 프로그래밍의 어려운 점 두 가지
  - 프로그래밍 언어 문법과 라이브러리 사용
  - 논리 (Hard Logic)

- 문법과 라이브러리
  - 많이 알려진 어려운 점
  - 위 프로그램이 무엇을 하는 것인지 처음 보는 사람은 알 수 없음
  - 능숙해 지기 위해 많은 훈련이 필요하지만, 이 과정의 중요 목표는 아님
  - 프로그래밍을 최초로 배울 때 약간의 어려움이 있지만 훈련에 비례하여 실력이 느는 경향이 있음
  - 일반 상식으로 원래 알고 있는 것이 아니기 때문에 훈련의 필요성에 대해 반감이 없음

- 논리 (Hard Logic)
  - Hard vs. Soft Logic
  - 카드 문제
    - 모든 카드 한쪽 숫자, 다른 쪽 알파벳
    - 한쪽이 D면 반대쪽 3
    - DF37 중에 D, 7 확인하면 됨.
  - 맥주집 문제
  - 직관/논리
  - 일상 생활에서는
    - Soft Logic이 빠르기 때문에 유용
    - 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재
  - 프로그래밍은 Hard Logic을 사용
    - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
    - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요
  - 오해의 근원
    - Soft Logic으로 알고리즘을 이해하려고 하는 것!
    - 알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안 봤기 때문
    - 증명을 봐도 이해가 안되는 것은 직관으로 이해하려고 하기 때문
    - 가끔 직관적으로 이해되는 알고리즘이 있지만 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능

### 참고
- 명제
  - 참이나 거짓을 알 수 있는 식이나 문장.
  - p, q, r, ... 로 표현.
  - 예시)
    - 서울은 대한민구의 수도다.
    - 1 + 1 = 3
- 진리값
  - 참이나 거짓을 표현
  - T, F 또는 1, 0
- 연산 (결합)
  - 부정 NOT
    - p가 명제일 때, 명제의 진리값이 반대
  - 논리곱 AND
    - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
  - 논리곱 OR
    - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
  - 배타적 논리함 XOR
    - p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제.
- 합성
  - 연산자 우선 순위
    - NOT > AND, OR > if/then, iff
  - 항진명제 : 진리값이 항상 참
  - 모순명제 : 진리값이 항상 거짓
  - 사건명제 : 항진명제도 모순명제도 아닌 명제
- 조건명제
  - p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제
  - p -> q
- 쌍방조건명제
  - p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
  - p <-> q
- 조건명제의 역, 이, 대우
  - 역 : q -> p
  - 이 : ~p -> ~q
  - 대우 : ~q -> ~p
- 증명
  - 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함
  - 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
  - 증명에 대한 수많은 오해가 p->q를 p<->q와 혼동하는 것에서 일어남
- 수학적 귀납법과 증명의 수준
  - 수학적 귀납법의 기본형
    - P(1)이 참이고, P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.
  - 수학적 귀납법의 강한 형태
    - P(1)이 참이고, P(1) and P(2) and ... and P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.

## 논리와 증명
- pass

## 수와 표현
- 약간의 설명
  - 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
  - k개의 비트를 사용하면 0qnxj 2^k - 1까지 표현 가능
  - 사실, 꼭 저 범위인 것은 아님. 약속하는 방식에 따라 다르지만, 어떤 경우든 최대 2^k 가지의 값ㅇ르 표현하는 것이 가능
    - 10진수로 k자리를 쓰면 0부터 10^k - 1까지 표현이 가능한 것과 완전히 동일한 과정
  - 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
    - 2^k - 1 >= n이 성립해야 함 -> 즉, 2^k >= n+1
    - 같은 의미로, k >= log(n+1) -> 약 log n 비트가 필요
    - x = log n과 2^x = n은 같은 말
    - 위의 식을 잘 보면, log n이란
      - 2의 몇 승이 n이 되느냐의 답
      - n을 표현하는 데 몇 비트가 필요한가의 답
      - 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐의 답
      - n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답
    - x = log n일 때 x와 n을 비교하면 x가 더 작고, n이 커질수록 엄청나게 달라진다
    - 10자리로 표현할 수 있는 10진수 값은 읽을 수도 없을 정도로 큰 값이다
    - 컴퓨터 분야에서 로그의 밑은 항상 2
    - 32비트 컴퓨터의 주소 공간은 2^32 약 40억개 주소